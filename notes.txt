----Ch-1
1. setup makefile and git

----Ch-2

2. using unistd.h library
	read() and STDIN_FILENO are from this lib

3. default term goes to "canonical" mode or "cooked" mode
	in this mode user input is only sent to program after the user presses enter [not usefull for texteditor]

4. we want "raw" mode
	Unfortunately, there is no simple switch you can flip to set the terminal to raw mode. Raw mode is achieved by turning off a great many flags in the terminal, which we will do gradually over the course of this chapter.

5. use Ctrl-D to tell read() "reached end of file"
	or use Ctrl-C to signal process to terminate immediately

6. adding 'q' to quit

7. turn off echoing
	The ECHO feature causes each key you type to be printed to the terminal, so you can see what you’re typing. This is useful in canonical mode, but really gets in the way when we are trying to carefully render a user interface in raw mode.
	Ctrl-c and type "reset" 

8. disable raw mode at exit
	We’ll save a copy of the termios struct in its original state, and use tcsetattr() to apply it to the terminal when the program exits.	

9. turn off canonical mode
	There is an ICANON flag that allows us to turn off canonical mode. This means we will finally be reading input byte-by-byte, instead of line-by-line.
	Now the program will quit as soon as you press q.

10. display keypresses
	iscntrl() from ctype.h to test control character since they are non printable 

11. turn off Ctrl-C and Ctrl-Z signals
	by default 
	Ctrl-C -> SIGINT : signal to the current process which causes it to terminate 
	Ctrl-Z -> SIGTSTP : signal to the current process which causes it to suspend

12. disable Ctrl-S and Ctrl-Q
	by default 
	they are used for software flow control
	Ctrl-S : stops data from being transmitted to terminal until 
	Ctrl-Q : which resumes data flow

13. Disable Ctrl-V

14. Fix Ctrl-M

15. Turn off all output processing

16. Miscellaneous flags

17. A timeout for read()

### now enableRawMode() gets us fully into raw mode

18. error handling
	add die() : prints an error and exits
	perror() from stdio.h [Most C library functions that fail will set the global errno variable to indicate what the error was. perror() looks at the global errno variable and prints a descriptive error message for it. It also prints the string given to it before it prints the error message, which is meant to provide context about what part of your code caused the error.]

19. Sections

----Ch-3

1. Press Ctrl-Q to quit
	macro : #define CTRL_KEY(k) ((k) & 0x1f)
	The CTRL_KEY macro bitwise-ANDs a character with the value 00011111, in binary.

2. Refactor keyboard input

### also stop printing out keypresses at this point.

	2.1. a function for low-level keypress reading
		editorReadKey()’s job is to wait for one keypress, and return it.
		(later) handle escape sequences 
	2.2. another function for mapping keypresses to editor operations.
		editorProcessKeypress() waits for a keypress, and then handles it.
		(later) it will map various Ctrl key combos

3. clear the screen [using VT100 Esscape sequences]
	render the editor's user interface to the screen after each keypress
	\x1b : escape character | We are writing an escape sequence to the terminal. Escape sequences always start with an escape character (27) followed by a [ character. Escape sequences instruct the terminal to do various text formatting tasks, such as coloring text, moving the cursor around, and clearing parts of the screen.
	2J : command | We are using the J command (Erase In Display) to clear the screen. Escape sequence commands take arguments, which come before the command. In this case the argument is 2, which says to clear the entire screen. <esc>[1J would clear the screen up to where the cursor is, and <esc>[0J would clear the screen from the cursor up to the end of the screen. Also, 0 is the default argument for J, so just <esc>[J by itself would also clear the screen from the cursor to the end.

[NOTE] : If we wanted to support the maximum number of terminals out there, we could use the ncurses library, which uses the terminfo database to figure out the capabilities of a terminal and what escape sequences to use for that particular terminal.
