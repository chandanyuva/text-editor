----Ch-1
1. setup makefile and git

----Ch-2

2. using unistd.h library
	read() and STDIN_FILENO are from this lib

3. default term goes to "canonical" mode or "cooked" mode
	in this mode user input is only sent to program after the user presses enter [not usefull for texteditor]

4. we want "raw" mode
	Unfortunately, there is no simple switch you can flip to set the terminal to raw mode. Raw mode is achieved by turning off a great many flags in the terminal, which we will do gradually over the course of this chapter.

5. use Ctrl-D to tell read() "reached end of file"
	or use Ctrl-C to signal process to terminate immediately

6. adding 'q' to quit

7. turn off echoing
	The ECHO feature causes each key you type to be printed to the terminal, so you can see what you’re typing. This is useful in canonical mode, but really gets in the way when we are trying to carefully render a user interface in raw mode.
	Ctrl-c and type "reset" 

8. disable raw mode at exit
	We’ll save a copy of the termios struct in its original state, and use tcsetattr() to apply it to the terminal when the program exits.	

9. turn off canonical mode
	There is an ICANON flag that allows us to turn off canonical mode. This means we will finally be reading input byte-by-byte, instead of line-by-line.
	Now the program will quit as soon as you press q.

10. display keypresses
	iscntrl() from ctype.h to test control character since they are non printable 

11. turn off Ctrl-C and Ctrl-Z signals
	by default 
	Ctrl-C -> SIGINT : signal to the current process which causes it to terminate 
	Ctrl-Z -> SIGTSTP : signal to the current process which causes it to suspend

12. disable Ctrl-S and Ctrl-Q
	by default 
	they are used for software flow control
	Ctrl-S : stops data from being transmitted to terminal until 
	Ctrl-Q : which resumes data flow

13. Disable Ctrl-V

14. Fix Ctrl-M

15. Turn off all output processing

16. Miscellaneous flags

17. A timeout for read()

### now enableRawMode() gets us fully into raw mode

18. error handling
	add die() : prints an error and exits
	perror() from stdio.h [Most C library functions that fail will set the global errno variable to indicate what the error was. perror() looks at the global errno variable and prints a descriptive error message for it. It also prints the string given to it before it prints the error message, which is meant to provide context about what part of your code caused the error.]

19. Sections

----Ch-3

1. Press Ctrl-Q to quit
	macro : #define CTRL_KEY(k) ((k) & 0x1f)
	The CTRL_KEY macro bitwise-ANDs a character with the value 00011111, in binary.

2. Refactor keyboard input

### also stop printing out keypresses at this point.

	2.1. a function for low-level keypress reading
		editorReadKey()’s job is to wait for one keypress, and return it.
		(later) handle escape sequences 
	2.2. another function for mapping keypresses to editor operations.
		editorProcessKeypress() waits for a keypress, and then handles it.
		(later) it will map various Ctrl key combos

3. clear the screen [using VT100 Esscape sequences]
	render the editor's user interface to the screen after each keypress
	\x1b : escape character | We are writing an escape sequence to the terminal. Escape sequences always start with an escape character (27) followed by a [ character. Escape sequences instruct the terminal to do various text formatting tasks, such as coloring text, moving the cursor around, and clearing parts of the screen.
	2J : command | We are using the J command (Erase In Display) to clear the screen. Escape sequence commands take arguments, which come before the command. In this case the argument is 2, which says to clear the entire screen. <esc>[1J would clear the screen up to where the cursor is, and <esc>[0J would clear the screen from the cursor up to the end of the screen. Also, 0 is the default argument for J, so just <esc>[J by itself would also clear the screen from the cursor to the end.

[NOTE] : If we wanted to support the maximum number of terminals out there, we could use the ncurses library, which uses the terminfo database to figure out the capabilities of a terminal and what escape sequences to use for that particular terminal.

4. reposition the cursor
	This escape sequence is only 3 bytes long, and uses the H command (Cursor Position) to position the cursor. The H command actually takes two arguments: the row number and the column number at which to position the cursor. So if you have an 80×24 size terminal and you want the cursor in the center of the screen, you could use the command <esc>[12;40H. (Multiple arguments are separated by a ; character.) The default arguments for H both happen to be 1, so we can leave both arguments out and it will position the cursor at the first row and first column, as if we had sent the <esc>[1;1H command. (Rows and columns are numbered starting at 1, not 0.)

5. Clear the screen on exit
	two exit points 
	- die()
	- when user presses Ctrl-Q to quit

6. tildes
	we’ll draw a tilde at the beginning of any lines that come after the end of the file being edited.
	We don’t know the size of the terminal yet, so we don’t know how many rows to draw. For now we just draw 24 rows.

7. global state

8. Window size, the easy way
	ioctl() -> sys/ioctl.h
	initEditor() it’s job will be to initialize all the fields in the E struct.

9. Window size, the hard way
	[The strategy is to position the cursor at the bottom-right of the screen, then use escape sequences that let us query the position of the cursor. That tells us how many rows and columns there must be on the screen.]

10. The last line
  When we print the final tilde, we then print a "\r\n" like on any other line, but this causes the terminal to scroll in order to make room for a new, blank line. Let’s make the last line an exception when we print our "\r\n"’s

